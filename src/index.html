<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - glTF loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.2/proj4.js"></script>

		<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB7xB3H3W19k4yyNsPrfgbRlBOfkrQIu4M" async defer></script>

			<!--<link rel="stylesheet" href="./style.css" />-->

		    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/>
		    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js" integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" crossorigin=""></script>

		<script src='js/Leaflet.GoogleMutant.js'></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/split.js/1.6.0/split.min.js"></script>

			<script type="text/javascript"  src="./js/Leaflet.VectorGrid.bundled.min.js"></script>

		<style>
		/*
		#container {
			display: flex;
		}

		#container_pano {
			width: 50%;
			display: inline-block;
			position: relative;
		}

		#container_overview {
			width: 50%;
			display: inline-block;
			position: relative;
		}

		#renderer_border {
			position: absolute;
			top: 0;
			left: 25%;
			bottom: 0;
			width: 2px;
			z-index: 999;
			opacity: .8;
			background: #ccc;
			border: 1px inset #ccc;
			cursor: col-resize;
		}
*/
		html, body {
	    height: 98%;
		background-color: black;
	  }
	  body {
	    /*padding: 8px;*/
	    background-color: #F6F6F6;
	    box-sizing: border-box;
	  }

		#container {
			height: 100%;
		}

	  .split {
	    -webkit-box-sizing: border-box;
	       -moz-box-sizing: border-box;
	            box-sizing: border-box;
	    overflow-y: hidden;
	    overflow-x: hidden;
	  }
	  .content {
	    /*border: 1px solid #C0C0C0;
	    box-shadow: inset 0 1px 2px #e4e4e4;*/
	    background-color: #fff;
		height: 100%;
	  }
	  .gutter {
	    background-color: transparent;
	    background-repeat: no-repeat;
	    background-position: 50%;
		background-color: #009069;
	  }
	  .gutter.gutter-horizontal {
	    cursor: col-resize;
	    background-image: url('../assets/vertical.png');
	  }

	  .split.split-horizontal, .gutter.gutter-horizontal {
	    height: 100%;
	    float: left;
	  }

	  #container_overview {
	    height:100%;
	  }

	  #container_pano {
	    width: 100% !important;
		height: 100%;
		background-color: black;
	  }

	  #a {

		width:100%;

	  }

	  #guiEl { position: absolute; top: 2px; left: 2px; z-index: 9999999999; }

		</style>

	</head>

	<body>

<div id="container">
	<!--<div id="container_pano"></div>
	<div id="container_overview"></div>
	<div id="renderer_border"></div>-->
	<div id="a" class="split split-horizontal">
       <div id="container_pano" class="split content"></div>
     </div>
     <div id="b" class="split split-horizontal">
 	<!--<img id="overlayImg" src="ARGeoVideo_overlay_up.png">-->
         <div id="container_overview" class="split content"></div>
 	<!--<button id="videoButtons" onClick="playPause()">Play/ Pause</button>-->
     </div>
</div>

<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

			}

		</script>

		<script type="module">

///start map



"use strict";(function(){var e=this,t="addEventListener",i="removeEventListener",s="getBoundingClientRect",n=e.attachEvent&&!e[t],r=e.document,o=function(){var e,t=["","-webkit-","-moz-","-o-"];for(var i=0;i<t.length;i++){e=r.createElement("div");e.style.cssText="width:"+t[i]+"calc(9px)";if(e.style.length){return t[i]+"calc"}}}(),a=function(e){if(typeof e==="string"||e instanceof String){return r.querySelector(e)}else{return e}},l=function(l,u){var c,f,p,g,h,d,z,S,y=[];u=typeof u!=="undefined"?u:{};if(typeof u.gutterSize==="undefined")u.gutterSize=10;if(typeof u.minSize==="undefined")u.minSize=100;if(typeof u.snapOffset==="undefined")u.snapOffset=30;if(typeof u.direction==="undefined")u.direction="horizontal";if(u.direction=="horizontal"){c="width";p="clientWidth";g="clientX";h="left";d="gutter gutter-horizontal";z="paddingLeft";S="paddingRight";if(!u.cursor)u.cursor="ew-resize"}else if(u.direction=="vertical"){c="height";p="clientHeight";g="clientY";h="top";d="gutter gutter-vertical";z="paddingTop";S="paddingBottom";if(!u.cursor)u.cursor="ns-resize"}var v=function(i){var s=this,n=s.a,r=s.b;if(!s.dragging&&u.onDragStart){u.onDragStart()}i.preventDefault();s.dragging=true;s.move=b.bind(s);s.stop=m.bind(s);e[t]("mouseup",s.stop);e[t]("touchend",s.stop);e[t]("touchcancel",s.stop);s.parent[t]("mousemove",s.move);s.parent[t]("touchmove",s.move);n[t]("selectstart",U);n[t]("dragstart",U);r[t]("selectstart",U);r[t]("dragstart",U);n.style.userSelect="none";n.style.webkitUserSelect="none";n.style.MozUserSelect="none";n.style.pointerEvents="none";r.style.userSelect="none";r.style.webkitUserSelect="none";r.style.MozUserSelect="none";r.style.pointerEvents="none";s.gutter.style.cursor=u.cursor;s.parent.style.cursor=u.cursor;M.call(s)},m=function(){var t=this,s=t.a,n=t.b;if(t.dragging&&u.onDragEnd){u.onDragEnd()}t.dragging=false;e[i]("mouseup",t.stop);e[i]("touchend",t.stop);e[i]("touchcancel",t.stop);t.parent[i]("mousemove",t.move);t.parent[i]("touchmove",t.move);delete t.stop;delete t.move;s[i]("selectstart",U);s[i]("dragstart",U);n[i]("selectstart",U);n[i]("dragstart",U);s.style.userSelect="";s.style.webkitUserSelect="";s.style.MozUserSelect="";s.style.pointerEvents="";n.style.userSelect="";n.style.webkitUserSelect="";n.style.MozUserSelect="";n.style.pointerEvents="";t.gutter.style.cursor="";t.parent.style.cursor=""},b=function(e){var t;if(!this.dragging)return;if("touches"in e){t=e.touches[0][g]-this.start}else{t=e[g]-this.start}if(t<=this.aMin+u.snapOffset){t=this.aMin}else if(t>=this.size-this.bMin-u.snapOffset){t=this.size-this.bMin}x.call(this,t);if(u.onDrag){u.onDrag()}},M=function(){var t=e.getComputedStyle(this.parent),i=this.parent[p]-parseFloat(t[z])-parseFloat(t[S]);this.size=this.a[s]()[c]+this.b[s]()[c]+this.aGutterSize+this.bGutterSize;this.percentage=Math.min(this.size/i*100,100);this.start=this.a[s]()[h]},x=function(e){this.a.style[c]=o+"("+e/this.size*this.percentage+"% - "+this.aGutterSize+"px)";this.b.style[c]=o+"("+(this.percentage-e/this.size*this.percentage)+"% - "+this.bGutterSize+"px)"},G=function(){var e=this,t=e.a,i=e.b;if(t[s]()[c]<e.aMin){t.style[c]=e.aMin-e.aGutterSize+"px";i.style[c]=e.size-e.aMin-e.aGutterSize+"px"}else if(i[s]()[c]<e.bMin){t.style[c]=e.size-e.bMin-e.bGutterSize+"px";i.style[c]=e.bMin-e.bGutterSize+"px"}},w=function(){var e=this,t=e.a,i=e.b;if(i[s]()[c]<e.bMin){t.style[c]=e.size-e.bMin-e.bGutterSize+"px";i.style[c]=e.bMin-e.bGutterSize+"px"}else if(t[s]()[c]<e.aMin){t.style[c]=e.aMin-e.aGutterSize+"px";i.style[c]=e.size-e.aMin-e.aGutterSize+"px"}},E=function(e){for(var t=0;t<e.length;t++){M.call(e[t]);G.call(e[t])}for(t=e.length-1;t>=0;t--){M.call(e[t]);w.call(e[t])}},U=function(){return false},D=a(l[0]).parentNode;if(!u.sizes){var k=100/l.length;u.sizes=[];for(f=0;f<l.length;f++){u.sizes.push(k)}}if(!Array.isArray(u.minSize)){var L=[];for(f=0;f<l.length;f++){L.push(u.minSize)}u.minSize=L}for(f=0;f<l.length;f++){var O=a(l[f]),B=f==1,F=f==l.length-1,A,C=u.gutterSize,N;if(f>0){N={a:a(l[f-1]),b:O,aMin:u.minSize[f-1],bMin:u.minSize[f],dragging:false,parent:D,isFirst:B,isLast:F,direction:u.direction};N.aGutterSize=u.gutterSize;N.bGutterSize=u.gutterSize;if(B){N.aGutterSize=u.gutterSize/2}if(F){N.bGutterSize=u.gutterSize/2}}if(!n){if(f>0){var R=r.createElement("div");R.className=d;R.style[c]=u.gutterSize+"px";R[t]("mousedown",v.bind(N));R[t]("touchstart",v.bind(N));D.insertBefore(R,O);N.gutter=R}if(f===0||f==l.length-1){C=u.gutterSize/2}if(typeof u.sizes[f]==="string"||u.sizes[f]instanceof String){A=u.sizes[f]}else{A=o+"("+u.sizes[f]+"% - "+C+"px)"}}else{if(typeof u.sizes[f]==="string"||u.sizes[f]instanceof String){A=u.sizes[f]}else{A=u.sizes[f]+"%"}}O.style[c]=A;if(f>0){y.push(N)}}E(y)};if(typeof exports!=="undefined"){if(typeof module!=="undefined"&&module.exports){exports=module.exports=l}exports.Split=l}else{e.Split=l}}).call(window);

	var prevTime = 0;
	var prevMarker;

	var currTrack;

	var highlightedLayer;

	var utilityFts;

	var tracksJSON = {

		"track1": {
			"loggedPos": null,
      "layerID_array": [],
      "prevMarker": null
		},
		"track2": {
			"videoSrc": "mobizen_20200806_193015.mp4",
			"videoStart": "2020/08/06 19:30:17", //"",
			"videoOffset": "",
			"videoTrim": 2,
      "loggedPos": null,
			"layerID_array": [],
      "prevMarker": null
		}

	};


    Split(['#a', '#b'], {
			sizes: [50, 50],
			minSize: 200,
      gutterSize: 8,
      cursor: 'col-resize',
	  onDragEnd: onDivResize
    });

        function componentToHex(c) {
          c = Math.round(c*255);
          var hex = c.toString(16);
          return hex.length == 1 ? "0" + hex : hex;
        }

        function rgbToHex(rgb) {
          r = Number(rgb[0]);
          g = Number(rgb[1]);
          b = Number(rgb[2]);
          var hexVal = "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
          //console.log(hexVal);
          return hexVal;
        }

	(async () => {
		fetch("./shots_reshoot2_NodeODM.geojson")
		.then(function(res) {
			return res.json();
		})
		.then(async function(data) {

			currTrack = "track1";
			await pointsToMap(data, "track1");

			tracksJSON.track1.loggedPos.eachLayer(function(layer) {
				tracksJSON.track1.layerID_array.push(layer._leaflet_id);
			});

			prevMarker = tracksJSON.track1.loggedPos.getLayer(tracksJSON.track1.layerID_array[0]);

			highlightedLayer = prevMarker;

			findBounds();

		});
	})();

	var map = L.map('container_overview'); //.setView([53.387, -6.265], 16);

	var streetmap = L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
		maxZoom: 20,
		maxNativeZoom: 20,
		attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
			'<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
			'Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
		id: 'mapbox/light-v9',
		tileSize: 512,
		zoomOffset: -1
	});//.addTo(map);

	var satellite = L.gridLayer.googleMutant({
		type: 'satellite'	// valid values are 'roadmap', 'satellite', 'terrain' and 'hybrid'
	}).addTo(map);

function style(feature) {
    return {
        fillColor: '#ff7800',
	opacity: 0.8
    };
}
	var highlight = {
		'fillColor': 'green'
	};

function findBounds() {

	var initBounds = {
		"min": {"lat":180, "lon":90},
		"max": {"lat":-180, "lon":-90}
	};

	loggedPointsArr.forEach(findMinMax);

	function findMinMax(item) {

		if (item[0] < initBounds.min.lat) {

			initBounds.min.lat = item[0];

		} else if (item[0] > initBounds.max.lat) {

			initBounds.max.lat = item[0];

		}

		if (item[1] < initBounds.min.lon) {

			initBounds.min.lon = item[1];

		} else if (item[1] > initBounds.max.lon) {

			initBounds.max.lon = item[1];

		}

	}

	console.log("initBounds ", initBounds);

	var calcBounds = new L.LatLngBounds([[initBounds.min.lat, initBounds.min.lon], [initBounds.max.lat, initBounds.max.lon]]);
	map.fitBounds(calcBounds, { padding: [20, 20] });

}


var loggedPointsArr = [];

	function onEachFeature(feature, layer) {

		loggedPointsArr.push([feature.geometry.coordinates[1], feature.geometry.coordinates[0]]);

		//var inTime = feature.properties.time.toString();

		//var popupContent = '<p>position ' + feature.geometry.coordinates + ', at time ' + feature.properties.time +
    //    	'\n <button onClick="playVideoHere(\'' + inTrack + '\',\'' + inTime + '\')">play here</button>';

		if (feature.properties && feature.properties.popupContent) {
			popupContent += feature.properties.popupContent;
		}

		//layer.bindPopup(popupContent);

		layer.on("click", function (e) {
			//console.log(loggedPos);
			//tracksJSON[inTrack].loggedPos.setStyle(style); //resets layer colors

			highlightedLayer.setStyle({fillColor: '#ff7800', opacity: 0.8});
			layer.setStyle({fillColor: '#ffff00'}); //highlight);  //highlights selected.
			layer.bringToFront();
			highlightedLayer = layer;

			onDocumentMouseDown1(layer);
		});

	}

	function pointsToMap(loggedPoints, trackNum) {
		tracksJSON[trackNum].loggedPos = L.geoJSON([loggedPoints], {

			style: function (feature) {
				return feature.properties && feature.properties.style;
			},

			onEachFeature: onEachFeature,

			pointToLayer: function (feature, latlng) {
				feature.properties.trackNumber = trackNum;
				return L.circleMarker(latlng, {
					radius: 8,
					fillColor: "#ff7800",
					color: "#000",
					weight: 1,
					opacity: 1,
					fillOpacity: 0.8
				});
			}
		}).addTo(map);
	}

const resizeObserver = new ResizeObserver(() => {
  map.invalidateSize();
});

var mapEl = document.getElementById("container_overview");

resizeObserver.observe(mapEl);



////////////////Vector Layer

var vectorStyleFromFile = {"EU_Drainage_-_Foul": {"color": "#ff00ff"}, "EU_ESB_Box": {"color": "#ff0000"}, "EU_Traffic_Pole": {"color": "#785200"}, "EU_Traffic_Assumed": {"color": "#785200"}, "EU_Water_Comm": {"color": "#0000ff"}, "EU_Eircom_IC": {"color": "#00ff00"}, "EU_Drainage_-_Surface": {"color": "#ff00ff"}, "EU_Traffic_Box": {"color": "#785200"}, "EU_ESB_Pole": {"color": "#ff0000"}, "EU_Virgin": {"color": "#ff7f00"}, "EU_Water_Comm_Box": {"color": "#0000ff"}, "EU_Gas_Assumed_Pipe": {"color": "#00ffff"}, "EU_Drainage_-_Combined": {"color": "#ff00ff"}, "EU_Drainage_Gully": {"color": "#ff00ff"}, "EU_Public_Lighting_Assumed_duct": {"color": "#b40000"}, "EU_Eircom_Box": {"color": "#00ff00"}, "EU_ESB_Assumed_Pipe": {"color": "#ff0000"}, "EU_Public_Lighting_IC": {"color": "#b40000"}, "EU_Traffic_IC": {"color": "#785200"}, "EU_Drainage_Assumed_Pipe": {"color": "#ff00ff"}, "EU_Water_Valve": {"color": "#0000ff"}, "EU_ESB_MV-LV": {"color": "#ff0000"}, "EU_Virgin_Assumed_duct": {"color": "#ff7f00"}, "EU_Public_Lighting_Probable_duct": {"color": "#b40000"}, "0": {"color": "#00ffff"}, "EU_Public_Lighting": {"color": "#b40000"}, "EU_Unidentified_Pipe": {"color": "#c0c0c0"}, "EU_Water_Assumed_Pipe": {"color": "#0000ff"}, "EU_ESB_HV": {"color": "#ff0000"}, "EU_ESB_Probable_Pipe": {"color": "#ff0000"}, "EU_Drainage_Probable_Pipe": {"color": "#ff00ff"}, "EU_ESB_Overhead_Cable": {"color": "#ff0000"}, "EU_Gas_Probable_Pipe": {"color": "#00ffff"}, "EU_Gas_Valve": {"color": "#00ffff"}, "EU_Gas_LP": {"color": "#00ffff"}, "EU_Eircom": {"color": "#00ff00"}, "EU_Public_Lighting_Box": {"color": "#b40000"}, "EU_Water_IC": {"color": "#0000ff"}, "EU_Eircom_Probable": {"color": "#00ff00"}, "EU_Virgin_Probable_duct": {"color": "#ff7f00"}, "EU_Eircom_Pole": {"color": "#00ff00"}, "EU_Water_Hydrant": {"color": "#0000ff"}, "EU_Public_Lighting_Pole": {"color": "#b40000"}, "EU_Virgin_IC": {"color": "#ff7f00"}, "EU_Eircom_Assumed": {"color": "#00ff00"}, "EU_Water_Probable_Pipe": {"color": "#0000ff"}, "EU_ESB_IC": {"color": "#ff0000"}, "EU_Water": {"color": "#0000ff"}, "EU_Drainage_Manhole": {"color": "#ff00ff"}, "EU_Unidentified_IC": {"color": "#c0c0c0"}, "EU_Traffic": {"color": "#785200"}, "EU_Virgin_Box": {"color": "#ff7f00"}};

var CADTilesUrl = "../assets/MG40041_tiles/{z}/{x}/{y}.pbf"; //"uncompressed_vector_tiles/{z}/{x}/{y}.pbf"; // //vector_tiles_lines_wgs84_fullExt/{z}/{x}/{y}.pbf"; //"vector_tiles/{z}/{x}/{y}.pbf";

var CADVectorTileOptions = {
	rendererFactory: L.canvas.tile, //L.svg.tile, //
	attribution: '',
	vectorTileLayerStyles: vectorStyleFromFile,
	interactive: true,
};

var CADTilesPbfLayer = L.vectorGrid.protobuf(CADTilesUrl, CADVectorTileOptions)
	.on('click', function(e) {	// The .on method attaches an event handler

		var attrs = e.layer.properties.autocad_layer;
		if (e.layer.properties.autocad_text_string) {
			attrs += "<br>" + e.layer.properties.autocad_text_string;
			console.log(attrs);
		}

		L.popup()
			.setContent(attrs)
			.setLatLng(e.latlng)
			.openOn(map);

		L.DomEvent.stop(e);
	})
	.addTo(map);

var overlays = {
	"utilities layer": CADTilesPbfLayer
};

var baseMaps = {
    "streetmap": streetmap,
    "satellite": satellite
};

L.control.layers(baseMaps, overlays).addTo(map);



///end map



		var orig_opt = {

			geojson: "./shots_0.geojson",
			pano_path: "../assets/panoramas/",
			imgExt: ".png",
			increment: 10

		};

		var re2_opt = {

			geojson: "./shots_reshoot2_UTM_fixed.geojson", //"./shots_reshoot2_reprocess_UTM.geojson", //
			pano_path: "../assets/panoramas_reshoot2/",
			imgExt: ".jpg",
			increment: 1

		};

		var data_opt = re2_opt; //orig_opt; //re_opt; //re4_opt_local;

		var SCREEN_WIDTH = window.innerWidth; //1200; //
		var SCREEN_HEIGHT = window.innerHeight; //600; //

		var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

		var options = {
			opacityLevel: 1,
			togglePanoramas: true,
			toggleBIM: true,
			lockOrbit: false,
			clippingFar: 100,
			debugCube: false,
			moveX: 0,
			moveY: 0,
			moveZ: 0,
			startX: 0,
			startY: 0,
			startZ: 0
		};

//////start clipping cylinder shader

	 var clippingSphere = {
		 value: new THREE.Vector4()
	 };

	 var params = {
	 	diffuse: "white",
	 	diffuseBack: "orange",
	 	inside: false
	};

     var diffuse = params.diffuse === undefined ? 0xffffff : params.diffuse;
     var diffuseBack = params.diffuseBack === undefined ? diffuse : params.diffuseBack;

     var inside = params.inside === undefined ? true : params.inside;
     inside = inside ? 1 : -1;

     let lambert = new THREE.ShaderMaterial({
       uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib.lambert.uniforms, {
         clippingSphere: {
					 value: new THREE.Vector4()
				 },
				 diffuse: {
					 value: new THREE.Color()
				 },
         diffuseBack: {
           value: new THREE.Color()
         }
       }]),

       vertexShader: THREE.ShaderLib.lambert.vertexShader
         .replace(/varying vec3 vLightFront;/g, 'varying vec3 vLightFront;\nvarying vec4 worldPosition;')
         .replace(/#include <worldpos_vertex>/g, 'worldPosition = modelMatrix * vec4( transformed, 1.0 );'),

       fragmentShader: THREE.ShaderLib.lambert.fragmentShader
         .replace(/uniform float opacity;/g, 'uniform float opacity;\nuniform vec4 clippingSphere;\nuniform vec3 diffuseBack;')
         .replace(/varying vec3 vLightFront;/g, 'varying vec3 vLightFront;\nvarying vec4 worldPosition;')
         .replace(/#include <clipping_planes_fragment>/g, '#include <clipping_planes_fragment>\n if (distance(worldPosition.xz, clippingSphere.xz) * sign(clippingSphere.w) < clippingSphere.w) discard;')
         .replace(/#include <dithering_fragment>/g, '#include <dithering_fragment>\n if (!gl_FrontFacing) gl_FragColor.xyz = diffuseBack;'),

       lights: true,

       side: THREE.DoubleSide,

       flatShading: true
     });

     lambert.uniforms.clippingSphere.value.set(0, 0, 0, options.clippingFar * inside);
     lambert.uniforms.diffuse.value.set(diffuse);
     lambert.uniforms.diffuseBack.value.set(diffuseBack);

//////end clipping cylinder shader

		import * as THREE from '../build/three.module.js';

		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { RGBELoader } from './jsm/loaders/RGBELoader.js';
		import { RoughnessMipmapper } from './jsm/utils/RoughnessMipmapper.js';

		import { PLYLoader } from './jsm/loaders/PLYLoader.js';

		import { PCDLoader } from './jsm/loaders/PCDLoader.js';

		var container, overviewContainer, controls;
		var overviewCamera, camera, scene, renderer, overviewRenderer;
		var gltfScene;
		var raycastArray = [];

		var panoMesh;

		var prevPano;

		var prevSprite;

		var shotList = [];

		var spriteList = [];

		var panoBIMGroup = new THREE.Group();

		var spriteGroup = new THREE.Group();

		var ringMesh;

		var border;

		var dcube;

		let screensplit = .25, screensplit_right = 0;

		let isUserInteracting = false,
			onPointerDownMouseX = 0, onPointerDownMouseY = 0,
			lon = 0, onPointerDownLon = 0,
			lat = 0, onPointerDownLat = 0,
			phi = 0, theta = 0;

		var gui = new dat.GUI(); //{ autoPlace: false });
		gui.domElement.id = "guiEl";
		//gui.domElement.style.zIndex = 10000;
		//gui.domElement.style.left = 0;
		//gui.domElement.style.position = "absolute";

		gui.add( options, 'opacityLevel', 0, 1 ).step( 0.01 ).name( 'opacity level' ).onChange( function ( value ) {
				//panoMesh.material.opacity = value;
				options.opacityLevel = value;

				console.log("prevPano ", prevPano);
				prevPano.material.opacity = value;
				renderer.render(scene, camera);
		} );

		gui.add( options, 'togglePanoramas' ).name( 'toggle panoramas' ).onChange( function ( value ) {
			//panoMesh.visible = value;
			console.log("prevPano vis ", prevPano);
			//prevPano.visible = value;
			function myFunction(item) {
				//console.log(item);
			  item.visible = value;
			  //document.getElementById("demo").innerHTML = sum;
			}
			shotList.forEach(myFunction);

			prevPano.visible = true;

			renderer.render(scene, camera);
		} );

		gui.add( options, 'toggleBIM' ).name( 'toggle BIM' ).onChange( function ( value ) {
			//for ( var i = 0; i < clickableObjects.length; i ++ ) {
			//  clickableObjects[ i ].visible = value;
			//}
			gltfScene.visible = value;
			renderer.render(scene, camera);
		} );

		gui.add( options, 'clippingFar', 5, 100 ).step( 0.1 ).name( 'visible distance' ).onChange( function ( value ) {
				options.clippingFar = value;
				//camera.far = value;
				var lP = lambert.uniforms.clippingSphere.value;
				//console.log("clipping ", lP, options);
				lambert.uniforms.clippingSphere.value.set(lP.x, lP.y, lP.z, options.clippingFar * inside);
				ringMesh.scale.set(options.clippingFar/100, options.clippingFar/100, options.clippingFar/100);
				camera.updateProjectionMatrix();
				renderer.render(scene, camera);
			//	console.log("clipping1 ", lP, options);
		} );

		gui.add( options, 'moveX', -10, 10 ).step( 0.1 ).name( 'move X' ).onChange( function ( value ) {
			//for ( var i = 0; i < clickableObjects.length; i ++ ) {
			//  clickableObjects[ i ].visible = value;
			//}
			gltfScene.position.x = options.startX + value;
			renderer.render(scene, camera);
		} );

		gui.add( options, 'moveY', -10, 10 ).step( 0.1 ).name( 'move Y' ).onChange( function ( value ) {
			//for ( var i = 0; i < clickableObjects.length; i ++ ) {
			//  clickableObjects[ i ].visible = value;
			//}
			gltfScene.position.y = options.startY + value;
			renderer.render(scene, camera);
		} );

		gui.add( options, 'moveZ', -10, 10 ).step( 0.1 ).name( 'move Z' ).onChange( function ( value ) {
			//for ( var i = 0; i < clickableObjects.length; i ++ ) {
			//  clickableObjects[ i ].visible = value;
			//}
			gltfScene.position.z = options.startZ + value;
			renderer.render(scene, camera);
		} );

		init();
		//render();
		animate();

		function init() {

			container = document.getElementById("container_pano");

			camera = new THREE.PerspectiveCamera( 90, 1, 0.01, 1000 );
			camera.position.set(- 1.8, 0.6, 2.7 );

			scene = new THREE.Scene();

			//scene.background = new THREE.Color().setHSL( 0.6, 0, 1 );
			//scene.fog = new THREE.Fog( scene.background, 1, 5000 );

		//	const groundGeo = new THREE.PlaneGeometry( 1000, 1000 );
		//	const groundMat = new THREE.MeshLambertMaterial( { color: 0xff0000 } );
		//	groundMat.color.setHSL( 0.095, 1, 0.75 );

		//	const ground = new THREE.Mesh( groundGeo, groundMat );
			//ground.position.y = - 33;
		//	ground.rotation.x = - Math.PI / 2;
		//	ground.receiveShadow = true;
			//scene.add( ground );

			const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 50, 0 );
			scene.add( hemiLight );

			const vertexShader = document.getElementById( 'vertexShader' ).textContent;
			const fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
			const uniforms = {
				"topColor": { value: new THREE.Color( 0x0077ff ) },
				"bottomColor": { value: new THREE.Color( 0x804426 ) },
				"offset": { value: 33 },
				"exponent": { value: 0.6 }
			};
		// /	uniforms[ "topColor" ].value.copy( hemiLight.color );

			//scene.fog.color.copy( uniforms[ "bottomColor" ].value );

	//		const skyGeo = new THREE.SphereGeometry( 800, 32, 15 );
	//		const skyMat = new THREE.ShaderMaterial( {
	//			uniforms: uniforms,
	//			vertexShader: vertexShader,
	//			fragmentShader: fragmentShader,
	//			side: THREE.BackSide
	//		} );

	//		const sky = new THREE.Mesh( skyGeo, skyMat );
	//		scene.add( sky );

	//		var size = 10;
	//		var divisions = 10;

	//		var gridHelper = new THREE.GridHelper( size, divisions );
	//		scene.add( gridHelper );

			const ringGeometry = new THREE.RingGeometry( options.clippingFar -0.3, options.clippingFar, 32 );
			const ringMaterial = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
			ringMesh = new THREE.Mesh( ringGeometry, ringMaterial );
			ringMesh.rotateX(Math.PI/2);
			scene.add( ringMesh );

		//	var light = new THREE.AmbientLight( 0x404040 ); // soft white light
		//	scene.add( light );

			var light = new THREE.DirectionalLight(0xffffff, 1);
			light.position.set(0, 50, 0);
			scene.add(light);

			var light2 = new THREE.DirectionalLight(0xffffff, 0.5);
			//light2.position.set(10, 5, -10);
			scene.add(light2);
/**/
			var loader = new GLTFLoader().setPath( '../assets/' );
			loader.load( '0_blender_export.gltf', function ( gltf ) { // 'ITM_from_IFC_exporter.gltf', function ( gltf ) {

				gltf.scene.traverse( function ( child ) {

					if ( child.isMesh ) {

					//	child.material = getMaterial({
				//		diffuse: "white",
				//		diffuseBack: "orange",
				//		inside: false
					//	});

						child.material = lambert;

						//child.material.depthTest = true;
				//		child.material.depthTest = false;
				//		child.material.depthWrite = false;
						//child.material = new THREE.MeshBasicMaterial({color: '#ff0000', side: THREE.DoubleSide});

					}

				} );

				gltfScene = gltf.scene;
				//gltfScene.renderOrder = 999;
				//gltfScene.onBeforeRender = function( renderer ) { renderer.clearDepth(); };

				gltfScene.renderOrder = 999;

				gltfScene.rotateX(Math.PI/2);

				gltfScene.position.set(1.3,1.5,0);

				panoBIMGroup.add(gltfScene);
				raycastArray.push(gltfScene);

				options.startX = gltfScene.position.x;
				options.startY = gltfScene.position.y;
				options.startZ = gltfScene.position.z;

			} );
/**/
			//	} );

		function rotate(vector, angleaxis) {
				var v = new THREE.Vector3(vector[0], vector[1], vector[2]);
				var axis = new THREE.Vector3(angleaxis[0], angleaxis[1], angleaxis[2]);
				var angle = axis.length();
				axis.normalize();
				var matrix = new THREE.Matrix4().makeRotationAxis(axis, angle);
				v.applyMatrix4(matrix);
				return v;
		}

		function opticalCenter(shot) {
				var angleaxis = [-shot.rotation[0], -shot.rotation[1], -shot.rotation[2]];
				var Rt = rotate(shot.translation, angleaxis);
				Rt.negate();
				return Rt;
		}

			(async () => {
				fetch("./shots_reshoot2_NodeODM.geojson") //data_opt.geojson) //shots_reshoot_UTM29N.geojson") //"./shots_0.geojson"
				.then(function(res) {
					return res.json();
				})
				.then(async function(data) {

					var xOff = 678790.3753; //712158.3404830345;
					var yOff = 5907109.1253; //727174.4985701079;
					//var zOff = 42.43303740163; //original ITM height

					//var zOff = 72.43303740163056;
					//var zOff = 41.7;
					var zOff = 98.5;

					//for (key in data.featureCollection) {
					data.features.map((feature) => {

						var [x, y, z] = feature.properties.translation; //geometry.coordinates;
						var [rx, ry, rz] = feature.properties.rotation;


						var UTM29N = "+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
						var ITM = "+proj=tmerc +lat_0=53.5 +lon_0=-8 +k=0.99982 +x_0=600000 +y_0=750000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";

						var WGS84 = "+proj=longlat +datum=WGS84 +no_defs";

					//	var xyITM = proj4(WGS84, UTM29N, [feature.geometry.coordinates[0], feature.geometry.coordinates[1]]);

					//	x = xyITM[0];
					//	y = xyITM[1];

						var gjBox = new THREE.Mesh(new THREE.SphereGeometry(0.25,72,72), new THREE.MeshBasicMaterial({color: '#ff0000'}));
//						var gjBox = new THREE.Mesh(new THREE.PlaneGeometry(1.92, 1.08), new THREE.MeshBasicMaterial({color: new THREE.Color().setHSL( Math.random(), 0.5, 0.5 ), map: texture1 /*, side: THREE.DoubleSide*/}));

						gjBox.rotateY(-Math.PI/2);

			function getMatrix(translation, rotation, scale) {
	        var axis = new THREE.Vector3(-rotation[0], -rotation[1], -rotation[2]);
	        var angle = axis.length();
	        axis.normalize();
	        var matrix = new THREE.Matrix4().makeRotationAxis(axis, angle);
	        matrix.setPosition(new THREE.Vector3(translation[0], translation[1], translation[2]));

	        if (scale != 1.0){
	            matrix.scale(new THREE.Vector3(scale, scale, scale));
	        }


	        return matrix;
	    }

			var getM = getMatrix(feature.properties.translation, feature.properties.rotation, 1.0);
			//console.log("getM", getM.elements);
			getM.elements[12] -= xOff;
			getM.elements[13] -= yOff;
			getM.elements[14] -= zOff;
			//console.log("getM1", getM.elements);
 			gjBox.applyMatrix4(getM);

						gjBox.userData.shot_id = feature.properties.filename;
						gjBox.userData.x = x;
						gjBox.userData.y = y;
						gjBox.userData.z = z;

						shotList.push(gjBox);

						//prevPano = shotList[0];

						gjBox.visible = false;
						//scene.add(gjBox);
						panoBIMGroup.add(gjBox);

					});

					//console.log("", shotList[0]);

					shotList.sort(function(a,b) {
						return parseInt(a.userData.shot_id.split(".")[0], 10) - parseInt(b.userData.shot_id.split(".")[0], 10);
					});

					//shotList = shotList.slice(0, 4);

					prevPano = shotList[4];

					scene.add(panoBIMGroup);
					panoBIMGroup.rotateX(-Math.PI/2);
					panoBIMGroup.updateMatrixWorld();

					moveCamera(prevPano);

				});
			})();

			renderer = new THREE.WebGLRenderer( { antialias: true, logarithmicDepthBuffer: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			//renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setSize(SCREEN_WIDTH / 2, SCREEN_HEIGHT);

			//renderer.domElement.style.position = "relative";
			//renderer.domElement.id = 'renderer_pano';

			container.appendChild( renderer.domElement );

			window.addEventListener( 'resize', onWindowResize, false );

			//overviewContainer.addEventListener('pointerdown', onDocumentMouseDown1);

			//document.addEventListener("mousedown", onDocumentMouseDown1, false);
			container.addEventListener( 'pointerdown', onPointerDown );


			function moveCamera(targetPano) {

				var targetSprite;

				for (var is = 0; is < tracksJSON[currTrack].layerID_array.length; is ++) {
					if (tracksJSON[currTrack].loggedPos._layers[tracksJSON[currTrack].layerID_array[is]].feature.properties.filename == targetPano.userData.shot_id) {
							targetSprite = tracksJSON[currTrack].loggedPos.getLayer(tracksJSON[currTrack].layerID_array[is]);//spriteList[is];
							//targetSprite.material.color.set("red");
							if (highlightedLayer) {
								highlightedLayer.setStyle({fillColor: '#ff7800'});
							}
							targetSprite.setStyle({fillColor: '#ffff00'});
							targetSprite.bringToFront();
							highlightedLayer = targetSprite;
							break;
					}
				}

				var panoPath = data_opt.pano_path + targetPano.userData.shot_id;

				var texPano = new THREE.TextureLoader().load( panoPath,
					function ( tex ) {

						tex.center = new THREE.Vector2(0.5, 0.5);
						//tex.rotation = Math.PI;
						tex.flipY = false;

						targetPano.scale.x = 1000;
						targetPano.scale.y = 1000;
						targetPano.scale.z = 1000;

						targetPano.renderOrder = 998;
						//targetPano.onBeforeRender = function( renderer ) { renderer.clearDepth(); };

						targetPano.material = new THREE.MeshBasicMaterial( { map: tex, side: THREE.DoubleSide, transparent: true, opacity: options.opacityLevel/*, depthFunc: THREE.NeverDepth*/ } );
						//targetPano.material.texture.needsUpdate = true;

						targetPano.material.depthWrite = false;

						targetPano.material.map.needsUpdate = true;
						targetPano.material.needsUpdate = true;
						targetPano.visible = true;
					//	 requestAnimationFrame(render);
					},
					// onProgress callback currently not supported
					undefined,
					function ( err ) {
						console.error( 'An error happened.' );
					}
				);


				//var iPos = intersects[0].object.position;
				var iPos = targetPano.matrixWorld.getPosition();

				camera.position.x = iPos.x;
				camera.position.y = iPos.y;
				camera.position.z = iPos.z;
				camera.updateProjectionMatrix();

				//controls.target.set( iPos.x - 0.001, iPos.y, iPos.z );

					//renderer.render(scene, camera);

				lambert.uniforms.clippingSphere.value.set(iPos.x, iPos.y, iPos.z, options.clippingFar * inside);

				ringMesh.position.set(iPos.x, iPos.y, iPos.z);
				ringMesh.scale.set(options.clippingFar/100, options.clippingFar/100, options.clippingFar/100);

	//			console.log("moved clip ", lambert.uniforms.clippingSphere.value);

				if (prevPano) {

					prevPano.scale.x = 1;
					prevPano.scale.y = 1;
					prevPano.scale.z = 1;

					prevPano.material = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});
					prevPano.material.needsUpdate = true;
					prevPano.visible = false;
				}

				prevPano = targetPano; //.object;

				renderer.render(scene, camera);

			}

			var guiButtons = {
				forward: function() {movePano("forward")}, //function(){ console.log("forward") },
				back: function() {movePano("back")} //function(){ console.log("back") },
			};

			gui.add(guiButtons,'forward').name('next panorama');
			gui.add(guiButtons,'back').name('previous pano');

			var prevJ = 4;

			var currPanoID1 = 0;

			function movePano(dirPano) {

				function getNearestPano1(inVal) {

					if ((inVal < 0) || (inVal > (shotList.length - 1))) {

						alert("At start/ end of photo list");

					} else {
						moveCamera(shotList[inVal]);
						prevJ = inVal;
					}
				}

				if(dirPano == "forward") {

					getNearestPano1(prevJ + 1);

				} else {

					getNearestPano1(prevJ - 1);

				}

			}

		}

		function onDocumentMouseDown1(layer) {

				var intersectSprite = layer.feature;

				var intersectPano;

				for (var is = 0; is < shotList.length; is ++) {
					if (shotList[is].userData.shot_id == intersectSprite.properties.filename) {
							intersectPano = shotList[is];
							//intersectSprite.material.color.set("red");
							break;
					}
				}

				var clickPanoPath = data_opt.pano_path + intersectSprite.properties.filename;
		//		console.log("intersects panopath ", clickPanoPath);
				var texIntersectLoad = new THREE.TextureLoader().load( clickPanoPath,
					function ( texIntersect ) {

						texIntersect.center = new THREE.Vector2(0.5, 0.5);
					//	texIntersect.rotation = Math.PI;
						texIntersect.flipY = false;

						intersectPano.scale.x = 1000;
						intersectPano.scale.y = 1000;
						intersectPano.scale.z = 1000;

						intersectPano.material = new THREE.MeshBasicMaterial( { map: texIntersect, side: THREE.BackSide, transparent: true, opacity: options.opacityLevel } );

						intersectPano.material.map.needsUpdate = true;
						intersectPano.material.needsUpdate = true;

						intersectPano.visible = true;

					},
					// onProgress callback currently not supported
					undefined,
					function ( err ) {
						console.error( 'An error happened.' );
					}
				);

				//var iPos = intersects[0].object.position;
				var iPos = intersectPano.matrixWorld.getPosition();

				camera.position.x = iPos.x;
				camera.position.y = iPos.y;
				camera.position.z = iPos.z;
				camera.updateProjectionMatrix();

				//controls.target.set( iPos.x/* - 0.001*/, iPos.y, iPos.z );

				//	renderer.render(scene, camera);

				if (prevPano) {
					prevPano.material = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});
					prevPano.material.needsUpdate = true;
					prevPano.visible = false;
					prevPano.scale.set(1, 1, 1);
				}

				prevPano = intersectPano;

		}

function onWindowResize() {

	//camera.aspect = window.innerWidth / window.innerHeight;
	//camera.updateProjectionMatrix();

	//renderer.setSize( window.innerWidth, window.innerHeight );

	updateRendererSizes();

	render();

}

					//

function animate() {

	requestAnimationFrame( animate );

	render();
	//stats.update();

}

function render() {

	//if ( screensplit_right != 1 - screensplit ) {

	//	updateRendererSizes();

	//}

	lat = Math.max( - 85, Math.min( 85, lat ) );
	phi = THREE.MathUtils.degToRad( 90 - lat );
	theta = THREE.MathUtils.degToRad( lon );

	const x = 500 * Math.sin( phi ) * Math.cos( theta );
	const y = 500 * Math.cos( phi );
	const z = 500 * Math.sin( phi ) * Math.sin( theta );

	camera.lookAt( x, y, z );

	function myFunction0(item) {
		//console.log(item);
		item.visible = false; //options.togglePanoramas;
			  //document.getElementById("demo").innerHTML = sum;
	}
	shotList.forEach(myFunction0);

	spriteGroup.visible = false;

	if (prevPano) {
		prevPano.visible = true;
	}


	renderer.render( scene, camera );

	//function myFunction1(item) {
		//console.log(item);
	//	item.visible = true;
		//document.getElementById("demo").innerHTML = sum;
	//}
	//shotList.forEach(myFunction1);

	if (prevPano) {
		prevPano.visible = false;
	}


	spriteGroup.visible = options.togglePanoramas;

}

function onPointerDown( event ) {

//		console.log("in on pointer down");
	if ( event.isPrimary === false ) return;

	isUserInteracting = true;

	onPointerDownMouseX = event.clientX;
	onPointerDownMouseY = event.clientY;

	onPointerDownLon = lon;
	onPointerDownLat = lat;

	document.addEventListener( 'pointermove', onPointerMove );
	document.addEventListener( 'pointerup', onPointerUp );

}

function onPointerMove( event ) {
//	console.log("in on pointer move");
	requestAnimationFrame(render);
	if ( event.isPrimary === false ) return;

	lon = ( onPointerDownMouseX - event.clientX ) * 0.1 + onPointerDownLon;
	lat = ( event.clientY - onPointerDownMouseY ) * 0.1 + onPointerDownLat;

}

function onPointerUp() {

	if ( event.isPrimary === false ) return;

	isUserInteracting = false;

	document.removeEventListener( 'pointermove', onPointerMove );
	document.removeEventListener( 'pointerup', onPointerUp );

}

function onBorderPointerDown() {

	// activate draggable window resizing bar
	window.addEventListener( "pointermove", onBorderPointerMove );
	window.addEventListener( "pointerup", onBorderPointerUp );

}

function onBorderPointerMove( ev ) {

	screensplit = Math.max( 0, Math.min( 1, ev.clientX / window.innerWidth ) );

}

function onBorderPointerUp() {

	window.removeEventListener( "pointermove", onBorderPointerMove );
	window.removeEventListener( "pointerup", onBorderPointerUp );

}

function updateRendererSizes() {

	// Recalculate size for both renderers when screen size or split location changes

	SCREEN_WIDTH = window.innerWidth;
	SCREEN_HEIGHT = window.innerHeight;

	screensplit_right = 1 - screensplit;

	renderer.setSize( screensplit * SCREEN_WIDTH, SCREEN_HEIGHT );
	camera.aspect = screensplit * SCREEN_WIDTH / SCREEN_HEIGHT;
	camera.updateProjectionMatrix();
	camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT );
	container.style.width = ( screensplit * 100 ) + '%';


}

		function onDivResize() {

				console.log("container resize");

				var containerDiv = document.getElementById("a");

				//console.log();

		//		camera.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
		//		camera.updateProjectionMatrix();

		//		renderer.setSize( containerDiv.clientWidth, containerDiv.clientHeight );

				var canvas = renderer.domElement;
			  // look up the size the canvas is being displayed
			  var widthC = containerDiv.clientWidth; //canvas.clientWidth;
			  var heightC = containerDiv.clientHeight; //canvas.clientHeight;

			  // adjust displayBuffer size to match
			  if (canvas.width !== widthC || canvas.height !== heightC) {
			    // you must pass false here or three.js sadly fights the browser
					console.log('canvas', canvas);
					console.log('widthC', typeof(widthC));

					canvas.style.width = widthC + 'px';
					canvas.style.height = heightC + 'px';

					//canvas.setAttribute('width', parseInt(widthC));
					//canvas.height = parseInt(heightC);

			    renderer.setSize(widthC, heightC, false);
			    camera.aspect = widthC / heightC;
			    camera.updateProjectionMatrix();

				}



				render();

				console.log('canvas1', canvas);

			}

		</script>
<!--<script type="text/javascript" src="./index.js"></script>-->
	</body>
</html>
